#!/usr/bin/python

import sys
import getopt
import struct

def exit_usage():
    sys.stderr.write("""
Usage: %s -o FILE [ -L loader.bin ] [ -c cmdline ] bzImage [initrd]
""".lstrip() % (sys.argv[0],))
    sys.exit(2)

# Defaults
loader_filename = "loader.bin"
load_address = 0x01000000
cmdline = "auto"
output_filename = None

# Parse command-line
(options, args) = getopt.getopt(sys.argv[1:], "o:L:c:")

# Handle arguments
if len(args) == 1:
    bzImage_filename = args[0]
    initrd_filename = None
elif len(args) == 2:
    (bzImage_filename, initrd_filename) = args
else:
    exit_usage()

# Handle options
for (opt, value) in options:
    if opt == '-o':
        output_filename = value
    elif opt == '-L':
        loader_filename = value
    elif opt == '-c':
        cmdline = value.replace("\r\n", " ").replace("\n", " ")
    else:
        raise AssertionError("BUG: Unrecognized option %r=%r" % (opt, value))

# Output filename must be specified
if output_filename is None:
    exit_usage()

# Read the loader
loader_data = open(loader_filename, "rb").read()

# Read the kernel bzImage
bzImage_data = open(bzImage_filename, "rb").read()

# Read the initial ramdisk
if initrd_filename is None:
    initrd_data = ""
else:
    initrd_data = open(initrd_filename, "rb").read()

# Create fake e820 memory map
# Entries are given as: (address64, length64, type32)
e820_map = ""
# e820: 0x00000000 - 0x0009efff (636 KiB) usable
e820_map += struct.pack("<QQL", 0x00000000, 0x0009f000, 1)
# e820: 0x0009f000 - 0x0009ffff (4 KiB) reserved
e820_map += struct.pack("<QQL", 0x0009f000, 0x00001000, 2)
# e820: 0x000a0000 - 0x01d7ffff (29.5 MiB less 640 KiB) usable
e820_map += struct.pack("<QQL", 0x000a0000, 0x01ce0000, 1)

# NBI header record
header = struct.pack("<LLLL",
    0x1b031336,     # NBI magic
    0x4,            # flags and length
    0x0000c00d,     # real-mode load address for the 512-byte header (ds:bx format)
    0x0000c200)     # real-mode execute address (cs:ip) format

# Load address
p = load_address

# loader.bin - must be loaded at load_address
assert p == load_address
header += struct.pack("<LLLL",
    0x00000004,         # FIXME: tags
    p,                  # Load address (32-bit linear address)
    len(loader_data),   # Image length in bytes
    len(loader_data))   # Memory length in bytes
p += len(loader_data)

# cmdline - kernel command line
cmdline += "\0" # Append NUL to end of string
header += struct.pack("<LLLL",
    0x00000004,         # FIXME: tags
    p,                  # Load address (32-bit linear address)
    len(cmdline),       # Image length in bytes
    len(cmdline))       # Memory length in bytes
p += len(cmdline)

# bzImage
p = (p & ~0xfff) + 0x1000   # Align to 4096-byte boundary
header += struct.pack("<LLLL",
    0x00000004,         # FIXME: tags
    p,                  # Load address (32-bit linear address)
    len(bzImage_data),  # Image length in bytes
    len(bzImage_data))  # Memory length in bytes
p += len(bzImage_data)

# initrd
p = (p & ~0xfff) + 0x1000   # Align to 4096-byte boundary
header += struct.pack("<LLLL",
    0x00000004,         # FIXME: tags
    p,                  # Load address (32-bit linear address)
    len(initrd_data),   # Image length in bytes
    len(initrd_data))   # Memory length in bytes
p += len(initrd_data)

# fake e820 memory map
p = (p & ~0xfff) + 0x1000   # Align to 4096-byte boundary
header += struct.pack("<LLLL",
    0x04000004,         # FIXME: tags
    p,                  # Load address (32-bit linear address)
    len(e820_map),      # Image length in bytes
    len(e820_map))      # Memory length in bytes
p += len(e820_map)

header += "\0" * (512 - len(header) - 16) # padding
header += struct.pack("<xxxBLHxxxxxx",
    0xea,           # ljmp absolute (JMP ptr16:32 - Jump far, absolute, addres given in operand)
    load_address,   # 32-bit linear address where loader.bin is loaded
    0x0008)         # 16-bit segment selector (protected-mode %cs register gets set to this value)

assert len(header) == 512

# Write the image
outfile = open(output_filename, "wb")
outfile.write(header)
outfile.write(loader_data)  # nbi_header->entries[0]
outfile.write(cmdline)      # nbi_header->entries[1]
outfile.write(bzImage_data) # nbi_header->entries[2]
outfile.write(initrd_data)  # nbi_header->entries[3]
outfile.write(e820_map)     # nbi_header->entries[4]
outfile.close()

# vim:set ts=4 sw=4 sts=4 expandtab:
